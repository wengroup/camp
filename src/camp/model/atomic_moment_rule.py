"""Helper functions to create the rules for generate atomic moments.

M_v,p = h_v1 \contract D_v2,
where D_v2 = r_ij \otimes r_ij ...

This is applied separately to each radial degree u of the moment M_uv, and thus the
radial index u is not included in the rules.

We require that v1<=v2, such that the indices of h_v1 are fully contracted away. Note,
that both v1 and v2 can be zero.
"""


from pathlib import Path
from typing import Any

from monty.serialization import dumpfn

from camp.utils import letter_index


def write_atomic_moment_rules(
    max_max_in_rank: int = 5,
    filename="atomic_moment_rules.yaml",
):
    """Write to a yaml file all the constructing rules of atomic moments.

    Args:
        max_max_in_rank: maximum rank of the moments to be contracted.
        filename: name of the file to write to.
    """

    rules = {}

    for max_in_rank in range(max_max_in_rank + 1):
        rules[max_in_rank] = {}
        max_out_rank = max_in_rank

        for out_rank in range(max_out_rank + 1):
            r = get_atomic_moment_rules(max_in_rank, out_rank)

            if r:
                rules[max_in_rank][out_rank] = r
                print(
                    f"max_in_rank = {max_in_rank}, out_rank = {out_rank}, "
                    f"num_rules {len(r)}"
                )

    dumpfn(rules, filename)

    file = Path(__file__).name
    with open(filename, "r") as f:
        original = f.read()
    with open(filename, "w") as f:
        f.write(
            f"# This file is automatically generated by {file}.\n"
            f"# Don't edit this file, but edit {file} instead.\n\n"
            f"# This file is not used by the code, but is for reference only.\n\n"
            f"# The out key denote the maximum rank v of the moments M_uv to be used.\n"
            f"# The next key denotes the actual output rank v of the moment M_uv.\n"
            f"# The `ranks`, a tuple of (v1, v2), lists the rank of the feature h_v1 \n"
            f"# and the rank of the dynadic product D_v2 = r_ij \otimes r_ij ... \n"
            f"# to obtain the moment Mu_v = h_v1 \contract D_v2. The `einsum_rule` \n"
            f"# gives the corresponding rule to obtain M_uv.\n\n"
        )
        f.write(original)


def get_atomic_moment_rules(max_in_rank: int, out_rank: int) -> list[dict[str, Any]]:
    """Get all the atomic moment constructing rules for a given max level.

    This find all rules such that the output rank v of M_v is equal to `out_rank`, given
    the maximum rank of the input D_v2. This assumes that the input rank v1 of h_v1 is
    available from 0 to `max_in_rank`.

    Returns:
        list[{ranks: list[int], einsum_rule: str}]. `ranks` are the angular part
         (i.e. v) of the moments M_uv, and `einsum_rule` gives the corresponding rule to
         contract them to get a tensor of rank `out_rank`.
    """
    if not out_rank <= max_in_rank:
        raise ValueError("out_rank must be <= max_in_rank.")
    rules = [[i, i + out_rank] for i in range(max_in_rank + 1 - out_rank)]

    contraction_rules = []
    for v1, v2 in rules:
        cr = _get_contraction_rules(v1, v2)
        contraction_rules.append({"ranks": [v1, v2], "einsum_rule": cr})

    return contraction_rules


def _get_contraction_rules(v1: int, v2: int) -> str:
    """
    Get a contraction rule that leads to a tensor.

    This requires the moments with the highest rank (largest v) to be contracted with
    all other moments. The indices of all other moments are contracted away.


    Args:
        v1: the rank of h_v1.
        v2: the rank of D_v2, which is dynadic product of r_ij.

    Example:
        >>> _get_contraction_rules(2, 3)
        "...ab,...abc->...d"
        >>> _get_contraction_rules(3, 3)
        "...abc,...abc->..."
        >>> _get_contraction_rules(0, 0)
        ""

    Returns:
        A string of the contraction rules to be used by `torch.einsum` to generate a
        tensor.
    """
    if not v1 <= v2:
        raise ValueError("v1 must be <= v2.")

    if v1 == v2 == 0:
        return ""

    indices = letter_index(v2)

    if v1 == 0:
        einsum_rule = ""
    else:
        einsum_rule = "..." + indices[:v1] + ","

    einsum_rule += "..." + indices + "->..." + indices[v1:]

    return einsum_rule


if __name__ == "__main__":
    write_atomic_moment_rules(max_max_in_rank=8)
